// COPYRIGHT Dassault Systemes 2022
//===================================================================
//
// TRAStCommand.cpp
// The state chart based command: TRAStCommand
//
//===================================================================
//
// Usage notes:
//
//===================================================================
//
//  Jun 2022  Creation: Code generated by the CAA wizard  Dell
//===================================================================
#include "TRAStCommand.h"
#include "CATIndicationAgent.h"
#include "CATMathPlane.h"

// MechanicalModeler Framework 
#include "CATIPrtContainer.h"          // To handle Part Conatiner 
#include "CATIPrtPart.h"               // To handle Part Object


#include "CATIMechanicalRootFactory.h" // To create Open Body
#include "CATIGSMTool.h"               // To handle GSMTool (Open Body)  
#include "CATMfErrUpdate.h"            // To handle Update Exceptions

#include "CATCreateExternalObject.h"
#include "CATFrmEditor.h"
#include "CATDocument.h"
#include "CATInit.h"
#include "CATIPrtContainer.h"

#include <iostream>
#include "CATIDescendants.h"
#include "CATIParmPublisher.h"
#include "CATICkeParm.h"
#include "CATICkeParmFactory.h"
#include "CATISpecObject.h"
#include "CATCkeGlobalFunctions.h"
#include "CATIPartRequest.h"
#include "CATMsgCatalog.h"
#include "CATIGSMLinePtPt.h"
#include "CATIGSMPoint.h"
#include "CATIGSMProceduralView.h"
#include "CATVisPropertiesValues.h"
#include "CATIVisProperties.h"

















CATCreateClass( TRAStCommand);


//-------------------------------------------------------------------------
// Constructor
//-------------------------------------------------------------------------
TRAStCommand::TRAStCommand() :
  CATStateCommand ("TRAStCommand", CATDlgEngOneShot, CATCommandModeExclusive) 
//  Valid states are CATDlgEngOneShot and CATDlgEngRepeat
  ,_Indication(NULL)
{
	_pFact     = NULL;

	_spPart  = NULL;

	_spPartCont = NULL;

	_spMainPartBody = NULL;

	_spGSMFactory = NULL;
}

//-------------------------------------------------------------------------
// Destructor
//-------------------------------------------------------------------------
TRAStCommand::~TRAStCommand()
{
   if (_Indication != NULL) 
      _Indication->RequestDelayedDestruction();
}


//-------------------------------------------------------------------------
// BuildGraph()
//-------------------------------------------------------------------------
void TRAStCommand::BuildGraph()
{

	CATFrmEditor * pEditor = NULL;

	pEditor = CATFrmEditor::GetCurrentEditor();
	if(!!pEditor)
	{
		CATDocument *  pDocument = pEditor->GetDocument();
		if(!!pDocument)
		{
			std::cout<<"doc is received" <<std::endl;
		}
		CATInit * pInit = NULL; 

		pDocument->QueryInterface(IID_CATInit,  (void**)& pInit);
		if(!!pInit)
		{
			std::cout<<"doc is received" <<std::endl;

			CATBaseUnknown * pRootContainer = pInit->GetRootContainer("CATIPrtContainer");

			if(!!pRootContainer)
			{
				CATIPrtContainer * pPrtContainer = (CATIPrtContainer*)pRootContainer;

				std::cout<<"CATIPrtContainer is received" <<std::endl;
				

				pPrtContainer->QueryInterface(IID_CATIGSMFactory, (void**)& _pFact);

				  
    // Phase 1: Retrieve the current Part container
    // --------------------------------------------- 
    CATIContainer_var             spCont       = _pFact ;
    CATIPrtContainer_var          _spPartCont   = spCont;
	_spGSMFactory = _spPartCont;
    _spPart       = _spPartCont -> GetPart();

				
            
        CATIBasicTool_var spCurrentTool = _spPart -> GetCurrentTool();

            CATISpecObject_var spCurrentFeat = _spPart->GetCurrentFeature();

			CATISpecObject_var spParentForGSMTool = _spPart;

			CATIMechanicalRootFactory_var spMechRoot = _spPartCont ;

			CATISpecObject_var spSpecTool;  

			 CATIPartRequest_var spPartRequest = _spPart ;
   if ( NULL_var == spPartRequest )
   {
	   std::cout <<"Error on CATIPartRequest" << std::endl;
	  
   }
   

   HRESULT rc = spPartRequest->GetMainBody("",_spMainPartBody);

			 

			std::cout<<"CATIMechanicalRootFactory_var is received" <<std::endl;
            
          
                HRESULT rc2 = spMechRoot -> CreateGeometricalSet("Naga",spParentForGSMTool,spSpecTool,0);

				_spPart -> SetCurrentFeature(_spMainPartBody);

				std::cout<<"SetCurrentFeature is received" <<std::endl;

				CATICkeParmFactory_var spParmPactory = _spPartCont;

				std::cout<<"CATICkeParmFactory is received" <<std::endl;

				CATUnicodeString Title1 = CATMsgCatalog::BuildMessage("MyHeader","Name",NULL,0,"Set");

				CATUnicodeString Title2 = CATMsgCatalog::BuildMessage("MyHeader","Spouse",NULL,0,"Set");

				CATICkeParm_var spCkeParm = spParmPactory->CreateString(Title1, Title2);

				std::cout<<"CATICkeParm is received" <<std::endl;

				CATISpecObject_var spSpecObj = _spMainPartBody;

				CATISpecObject_var spParameterSet = CATCkeGlobalFunctions::GetFunctionFactory()->GetCurrentSet(CATICkeFunctionFactory::Parameter,spSpecObj,CATCke::True);

				CATIParmPublisher_var spParmPublisher = spParameterSet;



				spParmPublisher->Append(spCkeParm);

				std::cout<<"CATICkeParm is Appended" <<std::endl;

				CATISpecObject_var spSpecObj2 = _spMainPartBody;

				spSpecObj2->Update();

				std::cout<<"Part is Updated" <<std::endl;

		double PointCord1[3] = { 0,0,0 };
		CATISpecObject_var spSpecObject1 = CreatePoint( PointCord1 ); 

		double PointCord2[3] = { 100,0,0 };
		CATISpecObject_var spSpecObject2 = CreatePoint( PointCord2 ); 

		InsertInProceduralView(spSpecObject1);
		InsertInProceduralView(spSpecObject2);


		CATLISTV(CATISpecObject_var) iaObjectsParam;

		iaObjectsParam.Append(spSpecObject1);
		iaObjectsParam.Append(spSpecObject2);

		CATISpecObject_var spSpecObject3 = CreateLinePtPt( iaObjectsParam ); 

		InsertInProceduralView(spSpecObject3);

		
				CATISpecObject_var spSpecObj4 = _spMainPartBody;

				spSpecObj4->Update();

				std::cout<<"Part is Updated with Line" <<std::endl;

				 CATIVisProperties * pIPropertiesOnLine = NULL ;
  rc = spSpecObject3->QueryInterface(IID_CATIVisProperties, (void**)&pIPropertiesOnLine) ;
  if ( FAILED(rc) )
  {
	  std::cout << "Error with the Line"<< std::endl;
     
  }

  CATVisPropertiesValues               MyPropertyOnLine ;
  CATVisPropertyType PropTypeOnLine = CATVPColor ;
  CATVisGeomType GeomTypeOnLine     = CATVPLine ;

  // The Line becomes red 
 // PropTypeOnLine = CATVPColor ;
  MyPropertyOnLine.SetColor(255,0,0);
  rc = pIPropertiesOnLine->SetPropertiesAtt(MyPropertyOnLine,
                                                PropTypeOnLine,
                                                GeomTypeOnLine);

   std::cout << " Line Colour Changed to Red "<< std::endl;








            


			}
		}
	}





}



//-------------------------------------------------------------------------
// ActionOne ()
//-------------------------------------------------------------------------
CATBoolean TRAStCommand::ActionOne( void *data )
{
  // TODO: Define the action associated with the transition 
  // ------------------------------------------------------

  return TRUE;
}

void TRAStCommand::InsertInProceduralView(CATISpecObject_var &ispSpecObject)
{
	CATTry
	{
		if(!ispSpecObject)
			return;
		CATIGSMProceduralView_var spGSMProcView = ispSpecObject;
		if(!!spGSMProcView)
		{
			spGSMProcView->InsertInProceduralView();
			ispSpecObject->Update();
		}
	}
	CATCatch(CATError, pError)
	{
	}
	CATEndTry;
}

CATIGSMPoint_var TRAStCommand::CreatePoint( double cord[3] )  
{


		CATIGSMPoint_var spCATIGSMPoint = _spGSMFactory->CreatePoint(cord);
		CATISpecObject_var spSpecObject = spCATIGSMPoint;
		InsertInProceduralView ( spSpecObject );
		return spSpecObject;
}

CATISpecObject_var TRAStCommand::CreateLinePtPt(CATLISTV(CATISpecObject_var) &iaObjectsParam)
{
    int size = iaObjectsParam.Size();
    CATISpecObject_var spFirst = iaObjectsParam [size - 1];
    CATISpecObject_var spSecond = iaObjectsParam [size];
    
    CATISpecObject_var spSpecTmp ;
    if ( NULL != _pFact ) { 
        // Create feature 
        CATIGSMLinePtPt_var spLine = _pFact -> CreateLine(spFirst,spSecond);
        spSpecTmp = spLine;
       
    }
    return spSpecTmp;
}
