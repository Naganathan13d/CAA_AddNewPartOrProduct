// COPYRIGHT Dassault Systemes 2022
//===================================================================
//
// TRAStCommand.cpp
// The state chart based command: TRAStCommand
//
//===================================================================
//
// Usage notes:
//
//===================================================================
//
//  Jun 2022  Creation: Code generated by the CAA wizard  Dell
//===================================================================
#include "TRAStCommand.h"
#include "CATIndicationAgent.h"
#include "CATMathPlane.h"

// MechanicalModeler Framework 
#include "CATIPrtContainer.h"          // To handle Part Conatiner 
#include "CATIPrtPart.h"               // To handle Part Object


#include "CATIMechanicalRootFactory.h" // To create Open Body
#include "CATIGSMTool.h"               // To handle GSMTool (Open Body)  
#include "CATMfErrUpdate.h"            // To handle Update Exceptions

#include "CATCreateExternalObject.h"
#include "CATFrmEditor.h"
#include "CATDocument.h"
#include "CATInit.h"
#include "CATIPrtContainer.h"

#include <iostream>
#include "CATIDescendants.h"
#include "CATIParmPublisher.h"
#include "CATICkeParm.h"
#include "CATICkeParmFactory.h"
#include "CATISpecObject.h"
#include "CATCkeGlobalFunctions.h"
#include "CATIPartRequest.h"
#include "CATMsgCatalog.h"
#include "CATIGSMLinePtPt.h"
#include "CATIGSMPoint.h"
#include "CATIGSMProceduralView.h"
#include "CATVisPropertiesValues.h"
#include "CATIVisProperties.h"
#include "CATDocumentServices.h"
#include "CATIDocRoots.h"
#include "CATIProduct.h"




















CATCreateClass( TRAStCommand);


//-------------------------------------------------------------------------
// Constructor
//-------------------------------------------------------------------------
TRAStCommand::TRAStCommand() :
  CATStateCommand ("TRAStCommand", CATDlgEngOneShot, CATCommandModeExclusive) 
//  Valid states are CATDlgEngOneShot and CATDlgEngRepeat
  ,_Indication(NULL)
{
	
}

//-------------------------------------------------------------------------
// Destructor
//-------------------------------------------------------------------------
TRAStCommand::~TRAStCommand()
{
   if (_Indication != NULL) 
      _Indication->RequestDelayedDestruction();
}


//-------------------------------------------------------------------------
// BuildGraph()
//-------------------------------------------------------------------------
void TRAStCommand::BuildGraph()
{

	

	CATDocument *pDoc = NULL;
	HRESULT rc = CATDocumentServices::New("Product",
		                          pDoc);

	std::cout << std::endl << " New CATDocument Product is created " << std::endl ;

	CATIDocRoots *piDocRootsOnDoc = NULL;
	rc = pDoc->QueryInterface(IID_CATIDocRoots,
		                      (void**) &piDocRootsOnDoc);

	CATListValCATBaseUnknown_var *pRootProducts = piDocRootsOnDoc->GiveDocRoots();

	std::cout << std::endl << " RootProducts List created " << std::endl ;


	CATIProduct_var spRootProduct = NULL_var;

	spRootProduct = (*pRootProducts)[1];
			delete pRootProducts;
			pRootProducts = NULL;
	CATIProduct *piProductOnRoot = NULL;
	rc = spRootProduct->QueryInterface(IID_CATIProduct,
		                               (void**) &piProductOnRoot);

	std::cout << std::endl << " Got the Root Product " << std::endl ;

	CATIProduct *piInstanceProd2 = NULL;
	CATUnicodeString partName ("Test1");

	rc = AddNewExternalComponent(piProductOnRoot,
		                           "Part",
								   partName,
								   &piInstanceProd2);

	std::cout << std::endl << " New Part Created and added " << std::endl ;	

	rc = CATDocumentServices::SaveAs(*pDoc, "D:\\tmp\\NewProduct.CATProduct");

	std::cout << std::endl << " New Product Saved " << std::endl ;

}

HRESULT TRAStCommand::AddExternalComponent(CATIProduct *iThisProd, CATDocument *iDocument, CATIProduct **oNewProduct)
{
	

	HRESULT rc = E_FAIL;
	
	if ( NULL != iDocument)
	{
		// Get RootProduct of the document to import.
		CATIDocRoots *piDocRootsOnDoc = NULL;
		rc = iDocument->QueryInterface(IID_CATIDocRoots,
			                           (void**) &piDocRootsOnDoc);
		if ( FAILED(rc) )
		{
			std::cout << "** QI on CATIDocRoots failed " << std::endl ;
			
		}
		
		CATListValCATBaseUnknown_var *pRootProducts = 
			piDocRootsOnDoc->GiveDocRoots();
		CATIProduct_var spRootProduct = NULL_var;
		if ( NULL != pRootProducts)
			if (pRootProducts->Size())
			{  
				// the root product is first element of
				// the list of root elements.
				spRootProduct = (*pRootProducts)[1];
				delete pRootProducts;
				pRootProducts = NULL;
			}
			
		piDocRootsOnDoc->Release();
		piDocRootsOnDoc=NULL;
		
		CATIProduct_var spProduct = NULL_var;
		if (NULL_var != spRootProduct)
		{
		// We have the root product from which one
			// will be agregated in "this"
/** @anchor err_1 iThisProduct not tested before use */ 
		spProduct = iThisProd->AddProduct   (spRootProduct);
		}
		else
		{
			CATUnicodeString docName = iDocument-> StorageName();
/** @anchor err_2 iThisProduct not tested before use */ 
			iThisProd->AddShapeRepresentation(CATUnicodeString("model"),
				                              docName);
			
		}

		rc = spProduct->QueryInterface(IID_CATIProduct, 
			                           (void**) &*oNewProduct);
		
	}
	return rc; 
} 

HRESULT TRAStCommand::AddNewExternalComponent(CATIProduct* iThisProd, const CATUnicodeString iDocumentType,const CATUnicodeString iPartNumber, CATIProduct** oNewProduct)
{
	

	HRESULT rc = E_FAIL;
	*oNewProduct = NULL;
	
	CATUnicodeString product = "Product";
	CATUnicodeString part = "Part";

	if ( (iDocumentType != product) &&  (iDocumentType != part) )
	{
		std::cout << " ERROR in AddNewExternalComponent : document type : " << iDocumentType.CastToCharPtr() << " is not allowed "<< std::endl ;
		return rc;
	}

	// Creation of document CATProduct/CATPart
	CATDocument *pNewDoc = NULL;
	rc = CATDocumentServices::New(iDocumentType,
		                          pNewDoc );
	if ( FAILED(rc) || (NULL==pNewDoc) )
	{
		std::cout << "ERROR : document Creation Failed" << std::endl;
		return rc;
	}

	
	std::cout <<  "CAAPstAddServices.m:	document of type " <<  iDocumentType.CastToCharPtr() << " created " << std::endl;
	

	// Import document in this product
	if ( SUCCEEDED( rc ) )
	{
		// Get RootProduct of the created document.
		CATIDocRoots *piDocRootsOnNewDoc = NULL;
		rc = pNewDoc->QueryInterface(IID_CATIDocRoots,
			                         (void**) &piDocRootsOnNewDoc);
		if ( SUCCEEDED( rc ) )
		{			
			CATListValCATBaseUnknown_var *pRootProducts =
				piDocRootsOnNewDoc->GiveDocRoots();
			CATIProduct_var spRootProduct;
			if (NULL != pRootProducts)
				if (pRootProducts->Size())
				{  
					// the root product is first element of
					// the list of root elements.
					spRootProduct = (*pRootProducts)[1];
					delete pRootProducts;
					pRootProducts = NULL;
				}
				
				piDocRootsOnNewDoc->Release();
				piDocRootsOnNewDoc=NULL;
			
				if (NULL_var != spRootProduct)
					{
					// Set PartNumber to the created root
					// ATTENTION : be sure that the part number is single
					// in a document .
					spRootProduct -> SetPartNumber(iPartNumber);
	
					// We have the root product from which one
					// will be agregated in "this"
/** @anchor err_3 spRootProduct : tester la valeur du pointeur ( !! ) */ 
					CATIProduct_var spProduct;
/** @anchor err_4 iThisProduct not tested before use */ 
					spProduct = iThisProd->AddProduct   (spRootProduct);
					if (NULL_var ==  spProduct ) return 2;
					rc = spProduct->QueryInterface(IID_CATIProduct, 
						                           (void**) &*oNewProduct);

				}
		}
	}
	return rc; 

}

